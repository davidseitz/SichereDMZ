Loki Cardinality Explosion Attack

What is an cardinality attack, explain the cardinality explosion mechanism based on the following diagram, Also explain how the Attack makes a constant Index growth more massive based on how many fields are used:
flowchart LR
    subgraph NORMAL["Normal Operation"]
        direction TB
        N1["Log Entry 1<br/>{job=nginx, host=web1}"]
        N2["Log Entry 2<br/>{job=nginx, host=web1}"]
        N3["Log Entry 3<br/>{job=nginx, host=web1}"]
        N4["..."]
        N5["Log Entry 1000<br/>{job=nginx, host=web1}"]
        
        N1 --> NS["Single Stream<br/>1 index entry"]
        N2 --> NS
        N3 --> NS
        N5 --> NS
    end
    
    subgraph ATTACK["Cardinality Attack"]
        direction TB
        A1["Log Entry 1<br/>{job=app, req_id=uuid-1}"]
        A2["Log Entry 2<br/>{job=app, req_id=uuid-2}"]
        A3["Log Entry 3<br/>{job=app, req_id=uuid-3}"]
        A4["..."]
        A5["Log Entry 1000<br/>{job=app, req_id=uuid-1000}"]
        
        A1 --> AS1["Stream 1<br/>index entry"]
        A2 --> AS2["Stream 2<br/>index entry"]
        A3 --> AS3["Stream 3<br/>index entry"]
        A5 --> AS1000["Stream 1000<br/>index entry"]
    end
    
    subgraph IMPACT["Impact"]
        direction TB
        I1["Index Size: 1 entry"]
        I2["Index Size: 1000 entries"]
        I3["Memory: O(1)"]
        I4["Memory: O(n)"]
        I5["Query: O(1)"]
        I6["Query: O(n)"]
    end
    
    NS --> I1
    NS --> I3
    NS --> I5
    
    AS1 --> I2
    AS1000 --> I2
    I2 --> I4
    I4 --> I6
    
    style NORMAL fill:#d4edda,stroke:#28a745
    style ATTACK fill:#f8d7da,stroke:#dc3545
    style IMPACT fill:#fff3cd,stroke:#ffc107

Scenario 	Label Structure 	Unique Streams 	Index Growth
Normal 	{job="nginx", host="web1"} 	1 	Constant
Attack (1K) 	{job="app", request_id="uuid-*"} 	1,000 	1,000x
Attack (100K) 	{job="app", request_id="uuid-*", trace_id="uuid-*"} 	100,000 	100,000x


Prerequesits: < Attacker comromised aFluentbit instance. 
Different from WAF DOS Attack since it exploits the trust relation ship between two hosts and not the communication: untrusted internet -> waf/webserver, but instead trusted logger -> centralized SIEM
-> Next Diagram shall be conveted to mermaid explaining the trust relationship bewtween different hosts

┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Internet      │──X──│   DMZ Zone      │──X──│  Security Zone  │
│   (Attackers)   │     │   (Web/WAF)     │     │    (Loki)       │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                       │                       │
        │   Firewall DENY       │   Firewall ALLOW      │
        │   (Port 3100)         │   (Trusted Endpoint)  │
        └───────────────────────┴───────────────────────┘

EInordnug im MITRE ATT&Ck Framework: MITRE ATT&CK 	T1565.001 (Stored Data Manipulation), T1499.003 (Application Exhaustion Flood)

CVE Reference
misconfiguration enables attacks similar to:

    CVE-2022-35957: Grafana Loki Authentication Bypass
    General class: "Misconfigured Centralized Logging Infrastructure"


Attack with only basic Fluentbit Loik/ Grafana Implementation -> Does not have authentication by default, anybody can send logs to the siem

Attck Sequnence is in the following Diagram add that Phase 1 has already have to have happend and is not further disscussed here
sequenceDiagram
    autonumber
    
    participant ATK as Attacker<br/>(External)
    participant WEB as Web Server<br/>(Trusted Endpoint)
    participant FW as Internal Firewall<br/>(Allowlist)
    participant LOKI as Loki Ingester<br/>(No Auth)
    participant IDX as Loki Index<br/>(BoltDB/TSDB)
    participant STORE as Chunk Store<br/>(Filesystem)
    
    Note over ATK,STORE: Phase 1: Initial Compromise
    
    ATK->>+WEB: Exploit web vulnerability<br/>(e.g., RCE, SSH key theft)
    WEB-->>-ATK: Shell access obtained
    
    Note over ATK,STORE: Phase 2: Reconnaissance
    
    ATK->>+WEB: cat /etc/fluent-bit/fluent-bit.conf
    WEB-->>-ATK: Loki endpoint: 10.10.30.2:3100<br/>Labels: job, host, etc.
    
    ATK->>+WEB: curl http://10.10.30.2:3100/ready
    WEB->>+FW: TCP SYN to 10.10.30.2:3100
    Note over FW: ✓ Source IP in allowlist<br/>✓ Destination in Security Zone
    FW->>+LOKI: Forward connection
    LOKI-->>-FW: "ready"
    FW-->>-WEB: "ready"
    WEB-->>-ATK: Loki accessible!
    
    Note over ATK,STORE: Phase 3: Cardinality Explosion Attack
    
    loop For each batch (N iterations)
        ATK->>+WEB: Execute attack script
        WEB->>WEB: Generate unique labels:<br/>{request_id=UUID, trace_id=UUID, ...}
        
        WEB->>+FW: POST /loki/api/v1/push<br/>[Mimics Fluent Bit traffic]
        Note over FW: ✓ Allowlist match<br/>✓ Looks like normal logs
        FW->>+LOKI: Forward log payload
        
        Note over LOKI: No authentication check!<br/>Accepts all pushes
        
        LOKI->>+IDX: Index new stream<br/>(unique label combination)
        IDX->>IDX: Create new series entry<br/>Memory allocation++
        IDX-->>-LOKI: Indexed
        
        LOKI->>+STORE: Store log chunk
        STORE-->>-LOKI: Stored
        
        LOKI-->>-FW: 204 No Content
        FW-->>-WEB: Success
        WEB-->>-ATK: Entry injected
    end
    
    Note over ATK,STORE: Phase 4: Impact Manifestation
    
    Note over IDX: Index size explodes<br/>Memory exhaustion<br/>OOM Kill imminent
    
    IDX->>IDX: Index lookup O(n) degrades<br/>Query latency: ms → seconds
    
    Note over LOKI: SIEM DENIAL OF SERVICE<br/>Queries timeout<br/>Alerting fails

Network flow diagram explaining how the attack moves through the network
flowchart TB
    subgraph INTERNET["Internet (Untrusted)"]
        ATK[("Attacker")]
    end
    
    subgraph DMZ["DMZ Zone (10.10.10.0/29)"]
        WAF["WAF<br/>10.10.10.3"]
        WEB["Web Server<br/>10.10.10.4<br/><b>COMPROMISED</b>"]
    end
    
    subgraph SECURITY["Security Zone (10.10.30.0/29)"]
        LOKI["Loki<br/>10.10.30.2:3100<br/><b>TARGET</b>"]
        SIEM["Grafana<br/>10.10.30.2:3000"]
    end
    
    subgraph INTERNAL_FW["Internal Firewall Rules"]
        RULE1["Rule: ALLOW<br/>src=10.10.10.4 (webserver)<br/>dst=10.10.30.0/29<br/>port=3100/tcp"]
        RULE2["Rule: DENY<br/>src=ANY<br/>dst=10.10.30.0/29<br/>port=3100/tcp"]
    end
    
    ATK -->|"Compromise"| WEB
    WEB -->|"Trusted Traffic"| RULE1
    RULE1 -->|"3️Allowed"| LOKI
    ATK -.->|"Blocked"| RULE2
    RULE2 -.->|"Denied"| LOKI
    
    LOKI <-->|"Queries"| SIEM
    
    classDef compromised fill:#ff6b6b,stroke:#c92a2a,color:white
    classDef target fill:#ffa94d,stroke:#e67700,color:black
    classDef firewall fill:#495057,stroke:#212529,color:white
    classDef normal fill:#69db7c,stroke:#2f9e44,color:black
    
    class WEB compromised
    class LOKI target
    class RULE1,RULE2 firewall
    class WAF,SIEM normal

Attack impact
 ATTACK IMPACT:                                         │   │
│   │  - 100,000 streams = ~100MB index overhead              │   │
│   │  - Query latency: ms → seconds → timeout                │   │
│   │  - OOM kill threshold reached

Technical implementation without countermeasures, no host authentification, any host can send data to siem if fw rules allow it, attack implemented wit a script:

The loki_cardinality_attack.py script implements:

    Fluent Bit Impersonation: Mimics legitimate log forwarder traffic
    Label Randomization: Generates UUID-based labels per entry
    Batch Processing: Efficient multi-threaded injection
    Attack Modes:
        safe: 5 PoC entries (proof of access)
        cardinality: Index explosion attack
        integrity: Fake security alert injection
        full: Combined attack

Sample Malicious Payload

{
  "streams": [{
    "stream": {
      "job": "application",
      "env": "production",
      "request_id": "550e8400-e29b-41d4-a716-446655440000",
      "trace_id": "7f3d8c2a-1b4e-4f5d-9a8b-3c6d7e8f9a0b",
      "span_id": "a1b2c3d4e5f6",
      "instance": "host-8f3a2c1d",
      "pod": "pod-7e9f8a6b3c2d"
    },
    "values": [
      ["1732838400000000000", "level=info msg=\"Normal log entry\""]
    ]
  }]
}

Each push creates a new unique stream because request_id, trace_id, etc. are randomized.
Usage Guide
Modular Benchmark Suite

The attack is implemented as a modular benchmark suite with numbered stages for reproducibility:

attacks/loki_stages/
├── 00_reset.sh      # Environment reset (./setup.sh restart)
├── 01_baseline.sh   # Pre-attack metrics capture
├── 02_attack.sh     # Launch cardinality attack
├── 03_verify.sh     # Post-attack verification
└── run_benchmark.sh # Master orchestrator

Full Benchmark Execution

# Execute complete benchmark with environment reset
./attacks/loki_stages/run_benchmark.sh

# Skip environment reset (use existing containers)
./attacks/loki_stages/run_benchmark.sh --skip-reset

# Run individual stages manually
./attacks/loki_stages/01_baseline.sh
./attacks/loki_stages/02_attack.sh
./attacks/loki_stages/03_verify.sh

Resultate

Memory Impact (Container-Level)
Metric 	Value
Baseline Memory 	46.25 MiB
Post-Attack Memory 	404.8 MiB
Memory Delta 	+357.60 MiB
Percentage Increase 	+757.8%
Stream Cardinality Impact (Loki Ingester)
Metric 	Value
Baseline Active Streams 	16
Post-Attack Active Streams 	5,000
New Streams Created 	4,984
Attack-Specific Streams 	4,975 (job="application")
Attack Performance Metrics
Metric 	Value
Attack Duration 	14.60 seconds
Injection Rate 	340.75 entries/second
Success Rate 	100%
Visual Impact Summary

MEMORY CONSUMPTION
──────────────────────────────────────────────────────────────────────────
Baseline   │████                                                    │  46 MiB
Post-Attack│████████████████████████████████████████████████████████│ 405 MiB
──────────────────────────────────────────────────────────────────────────
                              +757.8% INCREASE

ACTIVE STREAMS (Cardinality)
──────────────────────────────────────────────────────────────────────────
Baseline   │▌                                                       │    16
Post-Attack│████████████████████████████████████████████████████████│ 5,000
──────────────────────────────────────────────────────────────────────────
                              +31,150% INCREASE

Immediate Effects (Theoretical Projections)
Metric 	Before Attack 	After Attack (10K streams) 	After 100K streams (projected)
Index Size 	~1 MB 	~50 MB 	~500 MB
Query Latency (p99) 	50ms 	5000ms+ 	Timeout
Memory Usage 	46 MiB 	405 MiB 	OOM Kill
Active Streams 	~16 	~5,000 	~50,000

flowchart TD
    A["Cardinality Attack"] --> B["Index Size Explosion"]
    B --> C["Memory Exhaustion"]
    C --> D["Query Timeouts"]
    D --> E["Alert Queries Fail"]
    E --> F["Security Alerts Stop"]
    
    B --> G["Compaction Slowdown"]
    G --> H["Write Failures"]
    H --> I["Log Loss"]
    
    F --> J["Attacker Achieves<br/>SIEM Blindness"]
    I --> J
    
    style A fill:#ff6b6b,stroke:#c92a2a,color:white
    style J fill:#ff6b6b,stroke:#c92a2a,color:white
    style F fill:#ffa94d,stroke:#e67700
    style I fill:#ffa94d,stroke:#e67700


    Security Monitoring Blindness: Alerts stop firing during attack
    Incident Response Degradation: Cannot query historical logs
    Compliance Violations: Log integrity compromised (audit failures)
    Resource Costs: Emergency scaling or infrastructure replacement

Countermeasure host authentication implemented through adding a reverse proxy in front of the siem in order to prevent unauthorized hosts to send log data to the siem, Problem: webserver is already a trusted host some simple credential scraping easily ignores this defense mechanism
Component 	Before (Phase 1) 	After (Phase 2)
Loki Access 	Direct to :3100 	Via Nginx proxy on :3100
Authentication 	None 	HTTP Basic Auth
Config Location 	loki-config.yaml 	nginx/nginx.conf + .htpasswd

Nginx Configuration
server {
    listen 10.10.30.2:3100;
    auth_basic "SIEM Log Ingestion - Authorized Personnel Only";
    auth_basic_user_file /etc/nginx/.htpasswd;
    
    location / {
        proxy_pass http://127.0.0.1:3100;
    }
}

Phase 2 Attack Vector: Credential Scraping

Since the trusted endpoint (web_server) still needs to forward logs, its Fluent Bit configuration must contain valid credentials:

# /etc/fluent-bit/pipelines/ssh-logs.conf (on web_server)
[OUTPUT]
    Name             loki
    Host             10.10.30.2
    Port             3100
    http_user        loki-user           # ← SCRAPED
    http_passwd      a_secretPW#15secEt  # ← SCRAPED

sequenceDiagram
    participant ATK as Attacker
    participant WEB as Web Server<br/>(Compromised)
    participant PROXY as Nginx Proxy<br/>(Auth Enforced)
    participant LOKI as Loki Backend
    
    Note over ATK,LOKI: Step 1: Verify Auth Enforcement
    ATK->>WEB: Test unauthenticated access
    WEB->>PROXY: GET /ready (no creds)
    PROXY-->>WEB: HTTP 401 Unauthorized
    WEB-->>ATK: ✓ Auth patch confirmed active
    
    Note over ATK,LOKI: Step 2: Credential Scraping
    ATK->>WEB: grep -r http_passwd /etc/fluent-bit/
    WEB-->>ATK: http_passwd = a_secretPW#15secEt
    
    Note over ATK,LOKI: Step 3: Auth Bypass
    ATK->>WEB: GET /ready -u loki-user:passwd
    WEB->>PROXY: GET /ready (Basic Auth header)
    PROXY->>LOKI: Forward (auth validated)
    LOKI-->>PROXY: HTTP 200 ready
    PROXY-->>WEB: HTTP 200 ready
    WEB-->>ATK: ✓ Auth bypass successful!
    
    Note over ATK,LOKI: Step 4: Resume Cardinality Attack
    ATK->>WEB: Launch attack with scraped creds
    WEB->>PROXY: POST /push (auth + malicious payload)
    PROXY->>LOKI: Forward (looks legitimate)
    LOKI-->>ATK: Cardinality explosion proceeds

Benchmark results ähnlich

Unauthenticated /ready 	HTTP 401 Unauthorized ✓
Authenticated /ready (scraped creds) 	HTTP 200 OK ✓
Unauthenticated push 	HTTP 401 Unauthorized ✓
Authenticated push (scraped creds) 	HTTP 204 No Content ✓
Attack Impact (With Auth Bypass)
Metric 	Baseline 	Post-Attack 	Delta
Container Memory 	98.14 MiB 	430.8 MiB 	+332.55 MiB (+337.1%)
Ingester Streams 	0 	5,000 	+5,000
Attack Duration 	— 	11.24 seconds 	—
Injection Rate 	— 	440.88 entries/sec 	—
Console Output (Key Excerpts)

[PHASE2] Testing if Blue Team auth patch is in place...
[PHASE2] ✓ CONFIRMED: Endpoint requires authentication (HTTP 401)
[PHASE2]   Blue Team patch is ACTIVE

[PHASE2] Scraping credentials from local Fluent Bit configuration...
[PHASE2] ✓ CREDENTIALS SCRAPED SUCCESSFULLY!
[PHASE2]   Username: loki-user
[PHASE2]   Password: a_se****ecEt

[*] Verifying connectivity to http://10.10.30.2:3100
    [*] Phase 2: Testing unauthenticated access first...
    [+] CONFIRMED: Endpoint requires authentication (HTTP 401)
        Blue Team patch is in place!
    [+] Loki /ready endpoint: OK
    [!] AUTH BYPASS SUCCESSFUL: Scraped credentials valid!
    [+] Push API accessible: CONFIRMED
    [!] VULNERABILITY: Auth bypass via credential scraping!

Root Cause Analysis
Unauthenticated access is implemented but rate limiting still is missing

Appendix: File Locations
File 	Description
attacks/loki_stages/run_benchmark.sh 	Master benchmark orchestrator
attacks/loki_stages/00_reset.sh 	Environment reset stage
attacks/loki_stages/01_baseline.sh 	Pre-attack metrics capture
attacks/loki_stages/02_attack.sh 	Attack execution stage
attacks/loki_stages/03_verify.sh 	Post-attack verification
attacks/loki_attack_wrapper.sh 	Legacy attack automation wrapper
attacks/python-scripts/loki_cardinality_attack.py 	Core attack script
attacks/logs/loki_attack_*.log 	Attack execution logs
config/siem/loki-config-secure.yaml 	Hardened Loki configuration
config/fluent-bit/examples/loki-authenticated.conf 	Authenticated Fluent Bit config

